#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "tree.h"
#include "assembler.h"


/* new_node: create "standard node" with one or two children and
 * given operation
 */
treenode *new_node(int op, treenode *left, treenode *right) {
  treenode *new=(treenode *)malloc(sizeof(treenode));

#ifdef DEBUG_ME
  printf("new_node: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=(char *)NULL;

  return new;
}

/* new_node_value: create "standard node" with one or two children and
 * given operation and the given value
 */
treenode *new_node_value(int op, treenode *left, treenode *right, long value, int param) {
  treenode *new=(treenode *)malloc(sizeof(treenode));

#ifdef DEBUG_ME
  printf("new_node: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=(char *)NULL;
  new->value=value;

  return new;
}

/* new_leaf: create leaf - node with no children */
treenode *new_leaf(int op) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_leaf: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=(char *)NULL;

  return new;
}

/* new_named_leaf: create leaf with name (used for identifier or
 * value of number)
 */
treenode *new_named_leaf(int op, char *name) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_leaf: %i (%s), %s\n",op,rule_names[op],name);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=name;

  return new;
}

/* new_named_leaf_value: create leaf with name (used for identifier or
 * value of number)
 */
treenode *new_named_leaf_value(int op, char *name, long value) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_leaf_value: %d (%s), %s, %li, param: %d\n",op,rule_names[op],name,value);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=name;
  new->value=value;

  return new;
}

/* new_named_node: create node with one or two children and a name (can be
 * used for storing a procedure's name)
 */
treenode *new_named_node(int op, treenode *left, treenode *right, char *name) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_node: %i (%s), %s\n",op,rule_names[op],name);
#endif
  
  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=name;

  return new;
}

void write_indent(int indent) {
  int a;
  for(a=0;a<indent;a++) {
    printf("|");
  }
}

/* write_tree: display the tree generated by the attributed grammar; this tree willk
 * be traversed by iburg
 */
void write_tree(treenode *node, int indent) {
  write_indent(indent);
  printf("%s, %s, %s\n",rule_names[node->op],node->name,node->reg);
  if(node->child[0]!=(treenode *)NULL || node->child[1]!=(treenode *)NULL) {
    if(node->child[0]!=(treenode *)NULL) {
      write_tree(node->child[0], indent+1);
    }
    if(node->child[1]!=(treenode *)NULL) {
      write_tree(node->child[1], indent+1);
    }
  }
}


char* rec_tree(treenode *node){
  char* ret;
  if(node == (treenode*) NULL) return "NULL";

  asprintf(&ret, "(%s) %s<%d>[%s] (%s)", rec_tree(node->child[0]), rule_names[node->op], node->op,node->reg, rec_tree(node->child[1]) );

  return ret;
}

void debug_tree(treenode *node){
  #ifdef DEBUG_ME
    printf("%s\n", rec_tree(node));
  #endif
}




treenode *new_number_leaf(long value) {
  treenode *node;

        if(value==0) {
    node=new_leaf(OP_Zero);
  }
  else if(value==1) {
    node=new_leaf(OP_One);
  }
  else {
    node=new_leaf(OP_Number);
        }

  node->value=value;

  return node;
}

/*
  FIELD or
  PARAM
*/

treenode * new_id_leaf(struct symbol_t* symbols, char * name){
  treenode *new=(treenode *)malloc(sizeof(treenode));

  struct symbol_t* id = table_lookup(symbols, name);

  if(id == EMPTY_TABLE){
    printf("Error: could not create new id-leaf. no symbol named %s found!\n", name);
    exit(3);
  }

  #ifdef DEBUG_ME
    printf("new id leaf for %s reg %s\n", name, id->reg);
    debug_symbol_table(symbols);
  #endif

  new->name=name;
  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;

  if(id->type == TYPE_FIELD){
    new->offset = id->offset;
    new->op = OP_Fieldvariable;
    new->reg = id->reg;
  }else if(id->type == TYPE_VAR) {
   /* new->reg = getRegister(name); */
    new->op=OP_ID;
    new->param_index=id->param_index;
  }else if(id->type == TYPE_PARAM) {
  /*  new->reg = getRegister(name); */
    new->op=OP_ID;
    new->param_index=id->param_index;
  }else {
    printf("Symbol %s has a unknown type (%d)!\n", name, id->type);
    exit(4);
  }
  
  

  return new;
}


treenode * new_field_leaf(char* name, treenode * address_term, int offset){
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
  new->child[0]=address_term;
  new->child[1]=(treenode *)NULL;
  new->op=OP_Field;
  new->name=name;
  new->param_index=-1;
  new->offset = offset;

  return new;
}

treenode* new_cond_node(treenode* expr, treenode* condrec, long id) {
  treenode* c = new_node(OP_Cond, expr, condrec);

  c->value = id;
  return c;
}




void synth_reg(treenode* bnode, treenode* child){
  REG(bnode) = get_op_register(REG(child));
  move(REG(child), REG(bnode)); 
}





treenode * new_funccall_leaf(char * name, treenode * params) {
  treenode * c = new_node(OP_Call, params, (treenode *) NULL);
  c->name = strclone(name);

  return c;
}

/*
symbol_t* gen_para_regs(symbol_t* parameters, symbol_t* vars) {
  char *registers[6] = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};
  int i = 0;
  symbol_t *para_start = parameters;

  while (parameters != EMPTY_TABLE) {
    if (i > 5) {
      printf("Error: more than 6 function parameters by call!\n");
    }
    parameters->reg = strclone(registers[i++]);
    parameters = parameters->next;
  }

  #ifdef MY_DEBUG
  printf("#-- ASSIGNING PARAMETER REGISTERS\n");
  debug_symbol_table(para_start);
  printf("\n");
  #endif

  
  return para_start;
}*/


int saved_reg_offset(char* name) {
  int i = 8;
  int num = 0;

  while( strcmp(name, regs[i]) != 0 ) {
    if(isUsed(regs[i]))
      ++num;
    --i;
  }

  return num;
}

void set_params(treenode* node) {
  treenode* cur = node;
  int num_params = 1;

  printf("/* set params */\n");
  /* count params */
  while(cur->op == OP_Args) {
    num_params += 1;
    cur = LEFT_CHILD(cur);
  }

  cur = node;

  while(cur->op == OP_Args) {
    /* use values from stack to set param regs */
    printf("\tmovq %d(%%rsp), %%%s\n", 8*saved_reg_offset(RC_REG(cur)), param_regs[--num_params]);

    cur = LEFT_CHILD(cur);
  }

  printf("\tmovq %d(%%rsp), %%%s\n", 8*saved_reg_offset(REG(cur)), param_regs[--num_params]);

}

void free_params(treenode* node) {
  treenode* cur = node;

  while(cur->op == OP_Args) {
    freereg(RC_REG(cur));
    cur = LEFT_CHILD(cur);
  }

  freereg(REG(cur));
}