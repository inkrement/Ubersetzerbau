#include <stdlib.h>
#include <stdio.h>

#include "tree.h"

/* new_node: create "standard node" with one or two children and
 * given operation
 */
treenode *new_node(int op, treenode *left, treenode *right) {
  treenode *new=(treenode *)malloc(sizeof(treenode));

#ifdef DEBUG_ME
  printf("new_node: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=(char *)NULL;

  return new;
}

/* new_node_value: create "standard node" with one or two children and
 * given operation and the given value
 */
treenode *new_node_value(int op, treenode *left, treenode *right, long value, int param) {
  treenode *new=(treenode *)malloc(sizeof(treenode));

#ifdef DEBUG_ME
  printf("new_node: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=(char *)NULL;
  new->value=value;

  return new;
}

/* new_leaf: create leaf - node with no children */
treenode *new_leaf(int op) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_leaf: %i (%s)\n",op,rule_names[op]);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=(char *)NULL;

  return new;
}

/* new_named_leaf: create leaf with name (used for identifier or
 * value of number)
 */
treenode *new_named_leaf(int op, char *name) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_leaf: %i (%s), %s\n",op,rule_names[op],name);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=name;

  return new;
}

/* new_named_leaf_value: create leaf with name (used for identifier or
 * value of number)
 */
treenode *new_named_leaf_value(int op, char *name, long value) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_leaf_value: %i (%s), %s, %li, param: %d\n",op,rule_names[op],name,value);
#endif

  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;
  new->op=op;
  new->name=name;
  new->value=value;

  return new;
}

/* new_named_node: create node with one or two children and a name (can be
 * used for storing a procedure's name)
 */
treenode *new_named_node(int op, treenode *left, treenode *right, char *name) {
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
#ifdef DEBUG_ME
  printf("new_named_node: %i (%s), %s\n",op,rule_names[op],name);
#endif
  
  new->child[0]=left;
  new->child[1]=right;
  new->op=op;
  new->name=name;

  return new;
}

void write_indent(int indent) {
  int a;
  for(a=0;a<indent;a++) {
    printf("|");
  }
}

/* write_tree: display the tree generated by the attributed grammar; this tree willk
 * be traversed by iburg
 */
void write_tree(treenode *node, int indent) {
  write_indent(indent);
  printf("%s, %s, %s\n",rule_names[node->op],node->name,node->reg);
  if(node->child[0]!=(treenode *)NULL || node->child[1]!=(treenode *)NULL) {
    if(node->child[0]!=(treenode *)NULL) {
      write_tree(node->child[0], indent+1);
    }
    if(node->child[1]!=(treenode *)NULL) {
      write_tree(node->child[1], indent+1);
    }
  }
}


char* rec_tree(treenode *node){
  char* ret;
  if(node == (treenode*) NULL) return "NULL";

  asprintf(&ret, "(%s) %s<%d>[%s] (%s)", rec_tree(node->child[0]), rule_names[node->op], node->op,node->reg, rec_tree(node->child[1]) );

  return ret;
}

void debug_tree(treenode *node){
  #ifdef DEBUG_ME
    printf("%s\n", rec_tree(node));
  #endif
}




treenode *new_number_leaf(long value) {
  treenode *node;

        if(value==0) {
    node=new_leaf(OP_Zero);
  }
  else if(value==1) {
    node=new_leaf(OP_One);
  }
  else {
    node=new_leaf(OP_Number);
        }

  node->value=value;

  return node;
}

/*
  FIELD or
  PARAM
*/

treenode * new_id_leaf(struct symbol_t* symbols, char * name){
  treenode *new=(treenode *)malloc(sizeof(treenode));

  struct symbol_t* id = table_lookup(symbols, name);

  #ifdef DEBUG_ME
    printf("new id leaf for %s\n", name);
    debug_symbol_table(symbols);
  #endif

  if(id == EMPTY_TABLE){
    printf("Error: could not create new id-leaf. no symbol named %s found!\n", name);
    exit(4);
  }

  new->name=name;
  new->child[0]=(treenode *)NULL;
  new->child[1]=(treenode *)NULL;

  if(id->type == TYPE_FIELD){
    printf("FELD es sein! reg: %s\n", id->reg);

    new->offset = id->offset;
    new->op = OP_Fieldvariable;
  }else {
    printf("VAR es sein!\n");
    new->op=OP_ID;
    new->param_index=id->param_index;
  }
  
  

  return new;
}


treenode * new_field_leaf(char* name, treenode * address_term, int offset){
  treenode *new=(treenode *)malloc(sizeof(treenode));
  
  new->child[0]=address_term;
  new->child[1]=(treenode *)NULL;
  new->op=OP_Field;
  new->name=name;
  new->param_index=-1;
  new->offset = offset;

  return new;
}